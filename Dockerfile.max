# Multi-stage build for minimal image size
FROM python:3.12-alpine3.19 AS builder

# Build dependencies
RUN apk add --no-cache gcc musl-dev libffi-dev openssl-dev python3-dev

WORKDIR /build

# Create requirements.txt
RUN cat <<EOF > requirements.txt
pyyaml==6.0.1
jinja2==3.1.2
requests==2.31.0
aiohttp==3.9.1
asyncio==3.4.3
openai==0.28.0
anthropic==0.8.1
prometheus-client==0.19.0
python-dotenv==1.0.0
colorama==0.4.6
rich==13.7.0
tenacity==8.2.3
pydantic==2.5.3
jsonschema==4.20.0
EOF

RUN pip wheel --no-cache-dir --no-deps --wheel-dir /build/wheels -r requirements.txt

# Runtime stage
FROM python:3.12-alpine3.19

LABEL maintainer="llms-os@example.com" \
      version="2.0.0" \
      description="Enhanced LLMs_OS with monitoring"

# Install runtime dependencies
RUN apk add --no-cache libffi openssl curl && \
    adduser -D -u 1000 appuser

WORKDIR /app

# Copy wheels and install
COPY --from=builder /build/wheels /wheels
RUN pip install --no-cache /wheels/*

# Create application structure
RUN mkdir -p /app/LLMs_OS/actions

# Build LLMs_OS module
WORKDIR /app/LLMs_OS

# __init__.py
RUN cat <<EOF > __init__.py
"""LLMs_OS - Enhanced Workflow Automation System"""
__version__ = "2.0.0"
__author__ = "LLMs_OS Team"

from .core import execute_yaml
from .async_core import execute_yaml_async
from .cli import main
from .registry import register, get_action, list_actions

__all__ = [
    'execute_yaml',
    'execute_yaml_async',
    'main',
    'register',
    'get_action',
    'list_actions'
]
EOF

# exceptions.py
RUN cat <<EOF > exceptions.py
"""Custom exceptions for LLMs_OS"""

class LLMsOSException(Exception):
    """Base exception for LLMs_OS"""
    pass

class ActionNotFoundError(LLMsOSException):
    """Action not found in registry"""
    pass

class ValidationError(LLMsOSException):
    """YAML validation error"""
    pass

class ExecutionError(LLMsOSException):
    """Action execution error"""
    pass
EOF

# registry.py
RUN cat <<EOF > registry.py
"""Action registry for LLMs_OS"""

_ACTIONS = {}

def register(name):
    """Decorator to register an action"""
    def decorator(func):
        _ACTIONS[name] = func
        return func
    return decorator

def get_action(name):
    """Get an action by name"""
    if name not in _ACTIONS:
        raise KeyError(f"Action not found: {name}")
    return _ACTIONS[name]

def list_actions():
    """List all registered actions"""
    return list(_ACTIONS.keys())
EOF

# monitoring.py
RUN cat <<EOF > monitoring.py
"""Monitoring and metrics for LLMs_OS"""
from prometheus_client import Counter, Histogram, start_http_server
import time

task_counter = Counter('llms_os_tasks_total', 'Total tasks executed', ['action', 'status'])
task_duration = Histogram('llms_os_task_duration_seconds', 'Task execution time', ['action'])

def start_metrics_server(port=9090):
    """Start Prometheus metrics server"""
    try:
        start_http_server(port)
    except Exception:
        pass

def record_task(action, status, duration=0):
    """Record task metrics"""
    task_counter.labels(action=action, status=status).inc()
    if duration > 0:
        task_duration.labels(action=action).observe(duration)
EOF

# validators.py
RUN cat <<EOF > validators.py
"""YAML validation for LLMs_OS"""
import jsonschema

WORKFLOW_SCHEMA = {
    "type": "object",
    "properties": {
        "metadata": {
            "type": "object",
            "properties": {
                "title": {"type": "string"},
                "version": {"type": "string"}
            }
        },
        "tasks": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["action"],
                "properties": {
                    "action": {"type": "string"}
                }
            }
        }
    },
    "required": ["tasks"]
}

def validate_workflow(data):
    """Validate workflow YAML structure"""
    try:
        jsonschema.validate(instance=data, schema=WORKFLOW_SCHEMA)
        return True
    except jsonschema.exceptions.ValidationError as e:
        raise ValueError(f"Invalid workflow: {e.message}")
EOF

# core.py
RUN cat <<EOF > core.py
"""Core workflow execution engine"""
import yaml
import os
from pathlib import Path
from .registry import get_action

def execute_yaml(file_path: str) -> None:
    """Execute a workflow from a YAML file"""
    # Load workflow
    with open(file_path, 'r') as f:
        workflow = yaml.safe_load(f)
    
    # Import actions to ensure they're registered
    import LLMs_OS.actions
    
    # Get tasks
    tasks = workflow.get('tasks', [])
    context = {}
    
    # Execute each task
    for task in tasks:
        action_name = task.get('action')
        if not action_name:
            continue
        
        try:
            action = get_action(action_name)
            result = action(task, context)
            
            # Save result if requested
            if 'save_as' in task and result:
                context[task['save_as']] = result
        except Exception as e:
            print(f"❌ Error in action '{action_name}': {e}")
            raise
EOF

# async_core.py
RUN cat <<EOF > async_core.py
"""Async workflow execution engine"""
import yaml
import asyncio
from pathlib import Path
from .registry import get_action

async def execute_yaml_async(file_path: str) -> None:
    """Execute a workflow from a YAML file asynchronously"""
    # Load workflow
    with open(file_path, 'r') as f:
        workflow = yaml.safe_load(f)
    
    # Import actions to ensure they're registered
    import LLMs_OS.actions
    
    # Get tasks
    tasks = workflow.get('tasks', [])
    context = {}
    
    # Execute each task
    for task in tasks:
        action_name = task.get('action')
        if not action_name:
            continue
        
        try:
            action = get_action(action_name)
            
            # Check if action is async
            if asyncio.iscoroutinefunction(action):
                result = await action(task, context)
            else:
                result = action(task, context)
            
            # Save result if requested
            if 'save_as' in task and result:
                context[task['save_as']] = result
        except Exception as e:
            print(f"❌ Error in action '{action_name}': {e}")
            raise
EOF

# cli.py
RUN cat <<EOF > cli.py
"""Command-line interface for LLMs_OS"""
import sys
import argparse
from pathlib import Path
from .core import execute_yaml

def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(description='LLMs_OS - Workflow automation with LLMs')
    parser.add_argument('workflow', nargs='?', help='Path to workflow YAML file')
    parser.add_argument('--version', action='store_true', help='Show version')
    
    args = parser.parse_args()
    
    if args.version:
        print('LLMs_OS v2.0.0')
        return 0
    
    if not args.workflow:
        parser.print_help()
        return 1
    
    workflow_path = Path(args.workflow)
    if not workflow_path.exists():
        print(f"❌ Workflow file not found: {workflow_path}")
        return 1
    
    try:
        execute_yaml(str(workflow_path))
        return 0
    except Exception as e:
        print(f"❌ Workflow execution failed: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
EOF

# Actions __init__.py
RUN cat <<EOF > actions/__init__.py
"""Action modules"""
from . import print_message
from . import chat_completion
from . import http_request
from . import file_operations

__all__ = ['print_message', 'chat_completion', 'http_request', 'file_operations']
EOF

# Actions: print_message
RUN cat <<EOF > actions/print_message.py
"""Print message action"""
import re
from ..registry import register

COLORS = {
    'success': '\\033[92m',
    'error': '\\033[91m',
    'warning': '\\033[93m',
    'info': '\\033[94m',
    'debug': '\\033[90m',
    'reset': '\\033[0m'
}

@register('print_message')
def print_message(task, context):
    """Print a formatted message"""
    message = task.get('message', '')
    style = task.get('style', 'info')
    
    # Replace templates like {{ var }} or {{ var.attr }}
    def replace_var(match):
        var_path = match.group(1).strip()
        
        # Handle default values: {{ var | default('value') }}
        if '|' in var_path:
            var_part, default_part = var_path.split('|', 1)
            var_path = var_part.strip()
            # Extract default value from default('value')
            default_match = re.search(r"default\\(['\"](.+?)['\"]\\)", default_part)
            default_val = default_match.group(1) if default_match else ''
        else:
            default_val = ''
        
        # Navigate path (e.g., health_check.status_code)
        parts = var_path.split('.')
        value = context
        for part in parts:
            if isinstance(value, dict):
                value = value.get(part)
                if value is None:
                    return default_val if default_val else match.group(0)
            else:
                return default_val if default_val else match.group(0)
        
        return str(value) if value is not None else default_val
    
    message = re.sub(r'\\{\\{\\s*(.+?)\\s*\\}\\}', replace_var, message)
    
    color = COLORS.get(style, COLORS['info'])
    print(f"{color}{message}{COLORS['reset']}")
    return None
EOF

# Actions: file_operations
RUN cat <<EOF > actions/file_operations.py
"""File operations actions"""
from pathlib import Path
from ..registry import register

@register('file_read')
def file_read(task, context):
    """Read file content"""
    path = task.get('path', '')
    try:
        with open(path, 'r') as f:
            content = f.read()
        return {'content': content}
    except Exception as e:
        print(f"⚠️  File read failed: {e}")
        return None

@register('file_write')
def file_write(task, context):
    """Write content to file"""
    path = task.get('path', '')
    content = task.get('content', '')
    
    try:
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w') as f:
            f.write(content)
        return {'path': path}
    except Exception as e:
        print(f"⚠️  File write failed: {e}")
        return None
EOF

# Actions: http_request
RUN cat <<EOF > actions/http_request.py
"""HTTP request action"""
import requests
from ..registry import register

@register('http_request')
def http_request(task, context):
    """Make HTTP request"""
    url = task.get('url', '')
    method = task.get('method', 'GET').upper()
    headers = task.get('headers', {})
    data = task.get('data')
    
    try:
        response = requests.request(method, url, headers=headers, json=data)
        return {
            'status_code': response.status_code,
            'headers': dict(response.headers),
            'content': response.text
        }
    except Exception as e:
        print(f"⚠️  HTTP request failed: {e}")
        return None
EOF

# Actions: chat_completion
RUN cat <<EOF > actions/chat_completion.py
"""Chat completion action for LLM interactions"""
import os
from ..registry import register

@register('chat_completion')
def chat_completion(task, context):
    """Execute LLM chat completion"""
    provider = task.get('provider', 'openai')
    model = task.get('model', 'gpt-3.5-turbo')
    messages = task.get('messages', [])
    
    # Replace context variables in messages
    import re
    for msg in messages:
        if 'content' in msg:
            def replace_var(match):
                var_path = match.group(1).strip()
                parts = var_path.split('.')
                value = context
                for part in parts:
                    if isinstance(value, dict):
                        value = value.get(part)
                        if value is None:
                            return match.group(0)
                    else:
                        return match.group(0)
                return str(value) if value is not None else match.group(0)
            
            msg['content'] = re.sub(r'\\{\\{\\s*(.+?)\\s*\\}\\}', replace_var, msg['content'])
    
    if provider == 'openai':
        try:
            import openai
            openai.api_key = os.getenv('OPENAI_API_KEY')
            response = openai.ChatCompletion.create(
                model=model,
                messages=messages
            )
            return {
                'content': response.choices[0].message.content,
                'model': model,
                'provider': provider
            }
        except Exception as e:
            print(f"⚠️  OpenAI request failed: {e}")
            return None
    
    print(f"⚠️  Provider '{provider}' not supported")
    return None
EOF

# pyproject.toml
RUN cat <<EOF > /app/pyproject.toml
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "LLMs_OS"
version = "2.0.0"
requires-python = ">=3.10"
dependencies = []

[project.scripts]
llms-os = "LLMs_OS.cli:main"

[tool.setuptools]
packages = ["LLMs_OS", "LLMs_OS.actions"]
EOF

# Sample YAML workflows
RUN cat <<EOF > /app/example-workflow.yaml
metadata:
  title: "LLMs_OS Demo Workflow"
  version: "2.0.0"
  description: "Demonstration of LLMs_OS capabilities"

tasks:
  - action: print_message
    message: "🚀 Starting LLMs_OS workflow demonstration"
    style: "success"

  - action: file_write
    path: /tmp/demo.txt
    content: "Hello from LLMs_OS!"
    save_as: file_info

  - action: print_message
    message: "✅ File created at {{ file_info.path }}"
    style: "success"

  - action: file_read
    path: /tmp/demo.txt
    save_as: file_content

  - action: print_message
    message: "📄 File content: {{ file_content.content }}"
    style: "info"

  - action: http_request
    method: GET
    url: https://httpbin.org/json
    save_as: http_response

  - action: print_message
    message: "🌐 HTTP Status: {{ http_response.status_code }}"
    style: "info"

  - action: print_message
    message: "✨ Workflow completed successfully!"
    style: "success"
EOF

# Install package
RUN pip install --no-cache-dir -e /app

# Change ownership
RUN chown -R appuser:appuser /app

# Security: Run as non-root
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD python -c "import LLMs_OS; print('healthy')" || exit 1

ENTRYPOINT ["llms-os"]
CMD ["--help"]
